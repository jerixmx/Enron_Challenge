#!/usr/bin/env python

import os
import ast
from sys import argv
from re import sub

def main(argv):
    ## Check whether inputs satisfy requirements.
    if argCheck(argv):
        search_dir = getDir(argv)
        
        ## Strip stopwords from search terms
        stopwords = loadStopwords()
        terms = defSearchTerms(argv,stopwords)
        
        ## Checks whether there are anough search terms
        if lenCheck(terms) is False:
            return 1
        
        ## Check whether searching ALL or ANY of the terms
        AND_operator = ANDCheck(argv,len(terms))

        ## Load, reindex, or index depending on whether index exists and index freshness
        i_index = indexMode(search_dir, stopwords)

        showResults(AND_operator,terms,i_index)
    
    ## Return 1 if search fails argument check
    else:
        return 1
    return 0

def argCheck(argv):
    ## Show syntax for incomplete arguments or help invoked.
    if len(argv) < 4 or ('--help' or '-h') in argv:
        print('Incomplete arguments: ' + str(len(argv)))
        syntax_help()
        return False    
    ## Show syntax for -d not in arguments or no following directory
    elif '-d' not in argv or argv[len(argv)-1] == '-d':
        print('Specify search directory')
        syntax_help()
        return False
    ## Check whether directory exists
    elif not(dirExists(argv)):
        print('Search directory does not exist')
        return False
    return True

def syntax_help():
    print('Syntax: ./sfor <term1> <term2> ... <termn> -d <path/to/search> [-a]')
    print('-a : (optional) Only return results matching ALL terms')

def dirExists(argv):
    search_dir = getDir(argv)
    return os.path.exists(search_dir)

## Get directory following '-d' in arguments
def getDir(argv):
    i=1
    arg_length = len(argv)
    for i in range (arg_length-1):
        if argv[i] == '-d':
            search_dir = argv[i+1]
    return search_dir

def loadStopwords():
    with open('./nltk-stopwords', 'r') as f:
        stopwords = f.read().splitlines()
    return stopwords

def defSearchTerms(argv, stopwords):
    arg_length = len(argv)
    terms = set()
    for i in range(1,arg_length):
        if argv[i] not in ['-a', '-d', '-h', '--help']:
            ## Skip directory following '-d'
            if argv[i-1] != '-d':
                if argv[i].lower() not in stopwords:
                    ## Remove special characters
                    terms.add(sub('[^0-9a-zA-Z\s]', '',argv[i]))
    return terms

def lenCheck(terms):
    if len(terms) > 0:
        print('Search terms:\t' + str(terms).strip('{},'))
        return True
    else:
        print('No search term provided or search term is a stop word.')
        syntax_help()
        return False

def ANDCheck(argv,len_terms):
    if len_terms < 2:
        if '-a' in argv:
            print('Only 1 search term. Finding documents matching term.')
        else:
            print('Finding documents matching term.')
        return False
    elif '-a' in argv:
        print('Finding documents matching ALL terms.')
        return True
    else:
        print('Finding documents matching ANY of the terms.')
        return False

def indexMode(search_dir, stopwords):
    index_path = os.path.join(search_dir,'i_index.txt')
    if os.path.exists(index_path):
        ## Checks whether files have been modified since last indexing based on last modified dates.
        if checkIndexFresh(search_dir,index_path):
            print('Index found. Loading index.')
            return loadIndex(index_path)
        else:
            print('Changes in search directory detected since previous index. Reindexing.')
            return InvertedIndex(search_dir, index_path, stopwords)
    else:
        print('No index found. Indexing.')
        return InvertedIndex(search_dir, index_path, stopwords)

def checkIndexFresh(search_dir,index_path):
    index_time = os.path.getmtime(index_path)
    for subdir, dirs, files in os.walk(search_dir):
        for filename in files:
            if 'i_index.txt' not in filename:
                filepath = os.path.join(subdir,filename)
                ## Compare last-modified date of index and each files in search dir
                if os.path.getmtime(filepath) > index_time:
                    return False 
    return True

def loadIndex(index_path):
    with open(index_path) as f:
        index_file = f.read()
        i_index = ast.literal_eval(index_file)
    return i_index

def InvertedIndex(search_dir, index_path, stopwords):
    ## Store unique words in words
    ## Create directory of files as key and their content as value
    words, file_directory = buildWordsFiles(search_dir, stopwords)
    
    ## Create directory of words as key and a set of filepaths that contain the word as value
    i_index = dict()
    for word in words:
        i_index[word] = set()
        for path in file_directory.keys():
            if word in file_directory[path]:
                i_index[word].add(path)
    
    with open(index_path, 'w') as f: 
        f.write(str(i_index))
    
    ## Write 'words' to txt file for getting test cases
    # with open('./words.txt', 'w') as f: 
    #     for key in i_index: 
    #         f.write('%s\n' % (key))
    
    return i_index

def search(terms, i_index):
    
    extracted_index = {key: value for key,value in i_index.items() if key in terms}
    paths = set()
    for value in extracted_index.values():
        path_set = value
        for path in path_set:
            paths.add(path)

    path_words = dict()
    for path in paths:
        path_words[path] = set()
        for key in path_words.keys():
            for word in extracted_index.keys():
                if key in extracted_index[word]:
                    path_words[key].add(word)
    
    results = dict()
    rn = 1
    for key in path_words.keys():
        results[rn] = key
        rn += 1
    if rn > 1:
        print ('%i files found containing search terms.' %(rn-1))
        print ('ID\tMatched Terms')
        for rn in results:
            temp_path = results[rn]
            matches = str(path_words[temp_path]).strip('{}')
            print(f'%i\t%s' %(rn, matches))
            print(f'%s' % temp_path)
    else:
        print('No matches.')
        rn = 0

    return rn, results
        

def readFile(rn_max, results):
    while(True):
        if rn_max > 1:
            while(True):
                rn = input('Select ID of file to retrieve:\t')
                if rn.isdigit():
                    rn = int(rn)
                    break
        else:
            rn = rn_max
        if rn <= rn_max and rn > 0:
            break
    with open(results[rn],'r') as f:
        print(f.read())
    
    back_to_results = 'a'
    while(back_to_results.lower() not in {'yes','y','no','n'}):
        back_to_results = input('Go back to search results? (y/n)\t')
    if back_to_results.lower() in {'yes','y'}:
        return 1
    if back_to_results.lower() in {'no','n'}:
        return 0

def ANDSearch(terms, i_index):
    
    extracted_index = {key: value for key,value in i_index.items() if key in terms}
    paths = set()
    for value in extracted_index.values():
        path_set = value
        for path in path_set:
            paths.add(path)

    paths_intersection = set.intersection(*(set(values) for values in extracted_index.values()))
    
    results = dict()
    rn = 1
    for path in paths_intersection:
        results[rn] = path
        rn += 1

    if rn > 1:
        print ('%i files containing search terms.' %(rn-1))
        print ('ID\tFile')
        for rn in results:
            print(f'%i\t%s' %(rn, results[rn]))
    else:
        print('No matches.')
        rn = 0

    return rn, results



def showResults(AND_operator,terms,i_index):
    show_results = 1
    while show_results == 1:
        if AND_operator is False:
            rn_max, results = search(terms, i_index)
        else:
            rn_max, results = ANDSearch(terms, i_index)
        if rn_max > 0:
            show_results = readFile(rn_max,results)
        else:
            break

def buildWordsFiles(search_dir, stopwords):
    ## For storing unique words in the search dir
    words = set()
    ## For storing filepaths as key, content as values
    file_directory = dict()

    for subdir, dirs, files in os.walk(search_dir):
        for filename in files:
            ## Exclude index from processing
            if 'i_index.txt' not in filename:
                filepath = os.path.join(subdir,filename)
                with open(filepath, encoding='cp1252', mode='r') as f:
                    ## Remove special characters, exclude stopwords, and store words in 'content'
                    temp_string = sub('[^0-9a-zA-Z\s]', '', f.read())
                    content = set((temp_string.lower().split()))
                    content.difference_update(stopwords)
                
                    # add words in 'content' to 'words' set
                    words |= content
                    # Fill up dictionary
                    file_directory[filepath] = content
    
    return words, file_directory

main(argv)
