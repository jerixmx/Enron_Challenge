#!/usr/bin/env python

import os
import ast
from sys import argv
from re import sub


def main(argv):
    if argCheck(argv):
        ##Strip stopwords from search terms
        stopwords = loadStopwords()
        terms = defSearchTerms(argv,stopwords)
        print("Search terms:\t" + str(terms).strip("{},"))
        
        AND_operator = ANDCheck(argv,len(terms))

        search_dir = getDir(argv)
        index_path = os.path.join(search_dir,'i_index.txt')
        
        index_exists = os.path.exists(index_path)
        if index_exists:
            print("Index found")
            if checkIndexFresh(search_dir,index_path):
                i_index = loadIndex(index_path)
            else:
                print("Reindex")
                i_index = InvertedIndex(search_dir, index_path, stopwords)
        else:
            print("No index")
            i_index = InvertedIndex(search_dir, index_path, stopwords)

        show_results = 1
        while show_results == 1:
            if AND_operator is False:
                rn_max, results = search(terms, i_index)
            else:
                rn_max, results = ANDSearch(terms, i_index)
            if rn_max > 0:
                show_results = readFile(rn_max,results)
            else:
                break
    else:
        return 1
    return 0

def loadStopwords():
    stopwords_file = open("./nltk-stopwords", "r")
    stopwords = stopwords_file.read().splitlines()
    stopwords_file.close()
    return stopwords

def defSearchTerms(argv, stopwords):
    i=1
    arg_length = len(argv)
    terms = set()
    for i in range(1,arg_length):
        if argv[i] not in ["-a", "-d", "-h", "--help"]:
            if argv[i-1] != "-d":
                if argv[i].lower() not in stopwords:
                    terms.add(sub('[^0-9a-zA-Z\s]', '',argv[i]))
    return terms


def argCheck(argv):
    # Show syntax for incomplete arguments or help invoked.
    if len(argv) < 3 or ("--help" or "-h") in argv:
        print("Args < 3: " + str(len(argv)))
        syntax_help()
        return False    
    # Show syntax for -d not in arguments or no following
    elif not("-d" in argv) or argv[len(argv)-1] == "-d":
        print("Specify search directory")
        syntax_help()
        return False
    elif not(dirExists(argv)):
        print("Search directory does not exist")
        return False
    return True

def getDir(argv):
    i=1
    arg_length = len(argv)
    for i in range (arg_length-1):
        if argv[i] == "-d":
            search_dir = argv[i+1]
    return search_dir

def dirExists(argv):
    search_dir = getDir(argv)
    return os.path.exists(search_dir)

def ANDCheck(argv,len_terms):
    if "-a" in argv and len_terms > 1:
        print("Finding documents matching ALL terms.")
        return True
    else:
        if len_terms < 2:
            print("Only 1 search term. Reverting to default search.")
        print("Finding documents matching ANY of the terms")
        return False

def syntax_help():
    print("Syntax: python sfor <term1> <term2> ... <termn> -d <path/to/search> [-a]")
    print("-a : (optional) Only return results matching All terms")

def checkIndexFresh(search_dir,index_path):
    index_time = os.path.getmtime(index_path)
    for subdir, dirs, files in os.walk(search_dir):
        for filename in files:
            if "i_index.txt" not in filename:
                filepath = os.path.join(subdir,filename)
                if os.path.getmtime(filepath) > index_time:
                    return False #Index not fresh if modified time of files > modified time of index
    return True


def InvertedIndex(search_dir, index_path, stopwords):
    words = set()
    file_directory = dict()
    for subdir, dirs, files in os.walk(search_dir):
        for filename in files:
            if "i_index.txt" not in filename:
                filepath = os.path.join(subdir,filename)
                with open(filepath, encoding='cp1252', mode='r') as f:
                    # Get words in the file and remove stopwords
                    temp_string = sub('[^0-9a-zA-Z\s]', '', f.read())
                    content = set((temp_string.lower().split()))
                    content.difference_update(stopwords)
                    # add content to words set
                    words |= content
                    # Fill up dictionary with filepath as key and content as value
                    file_directory[filepath] = content
    i_index = dict()
    for word in words:
        i_index[word] = set()
        for key in file_directory.keys():
            if word in file_directory[key]:
                i_index[word].add(key)
    
    with open(index_path, 'w') as f: 
        f.write(str(i_index))
    
    ## For getting test cases
    # with open("/mnt/42324F4B324F4361/PC Documents/01 - Jeri/Software Dev/Yosemite Labs/words.txt", 'w') as f: 
    #     for key in i_index: 
    #         f.write('%s\n' % (key))
    
    return i_index


# Inverted index: Dictionary
    # Key: word
    # Value: set(filenames)

def loadIndex(index_path):
    with open(index_path) as f:
        index_file = f.read()
        i_index = ast.literal_eval(index_file)
    return i_index

def search(terms, i_index):
    
    extracted_index = {key: value for key,value in i_index.items() if key in terms}
    paths = set()
    for value in extracted_index.values():
        path_set = value
        for path in path_set:
            paths.add(path)

    path_words = dict()
    for path in paths:
        path_words[path] = set()
        for key in path_words.keys():
            for word in extracted_index.keys():
                if key in extracted_index[word]:
                    path_words[key].add(word)
    
    results = dict()
    rn = 1
    for key in path_words.keys():
        results[rn] = key
        rn += 1
    if rn > 1:
        print ("%i files containing search terms." %(rn-1))
        print ("ID\tMatched Words")
        for rn in results:
            temp_path = results[rn]
            matches = str(path_words[temp_path]).strip("{}")
            print(f"%i\t%s" %(rn, matches))
            print(f"%s" % temp_path)
    else:
        print("No matches.")
        rn = 0

    return rn, results
        

def readFile(rn_max, results):
    while(True):
        if rn_max > 1:
            rn = int(input("Select ID of file to retrieve:\t"))
        else:
            rn = rn_max
        if rn <= rn_max and rn > 0:
            break
    with open(results[rn],'r') as f:
        print(f.read())
    
    back_to_results = "a"
    while(back_to_results.lower() not in {"yes","y","no","n"}):
        back_to_results = input("Go back to search results? (y/n)\t")
    if back_to_results.lower() in {"yes","y"}:
        return 1
    if back_to_results.lower() in {"no","n"}:
        return 0

def ANDSearch(terms, i_index):
    
    extracted_index = {key: value for key,value in i_index.items() if key in terms}
    paths = set()
    for value in extracted_index.values():
        path_set = value
        for path in path_set:
            paths.add(path)

    paths_intersection = set.intersection(*(set(values) for values in extracted_index.values()))
    
    results = dict()
    rn = 1
    for path in paths_intersection:
        results[rn] = path
        rn += 1

    if rn > 1:
        print ("%i files containing search terms." %(rn-1))
        print ("ID\tFile")
        for rn in results:
            print(f"%i\t%s" %(rn, results[rn]))
    else:
        print("No matches.")
        rn = 0

    return rn, results

main(argv)
